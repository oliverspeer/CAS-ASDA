---
title: "sharing_speeroli"
author: "Oliver Speer"
editor: source
lang: de
language: 
  title-block-author-single: "Autor:"
  title-block-published: "Version vom:"
date: "`r Sys.Date()`"
format:
  html:
    embeded-resources: true
    theme: cosmo
---

```{r setup, echo=FALSE, message=FALSE, warning=FALSE}
library(tidyverse)
library(GGally)
load("sharing_2024.rda") #C:\\ZHAW CAS datascience\\CAS-ASDA\\

# sort rows with NA into a new dataframe
sharing_na <- sharing[!complete.cases(sharing),]
sharing.t <- sharing[complete.cases(sharing),]

```

# Einführung {.justify}

# Problemstellung und Lösungsansatz {.justify}

# Explorative Datenanalyse {.justify}

```{r echo=FALSE, message=FALSE, warning=FALSE}
glimpse(sharing)
```

Folgenden Spalten enthalten fehlende Werte:

```{r echo=FALSE, message=FALSE, warning=FALSE}
df <- sharing |> summarise(across(everything(), ~sum(is.na(.))))
df
```

Ausser den 456 fehlenden Nutzerzahlen, die nach der Modellierung prognostiziert werden sollen, sind keine weiteren fehlenden Werte vorhanden.

In der Variable `user` sind `r sum(sharing$user == 0, na.rm = TRUE)` Nullen und `r sum(sharing$user == !floor(sharing$user), na.rm = TRUE)` Kommazahlen enthalten. D.h. die Zielgrösse `user` ist eine Zähldatenvariable und könnte als Poisson- oder Negativ-Binomial-Verteilung modelliert werden. Da der Anteil der Nullen sehr gering ist, ist ein zero-inflated Modell nicht notwendig.

## Graphische Darstellungen

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  # mutate(stunde = as.factor(stunde)) |>
  # group_by(wochentag) |>
  dplyr::select(user, temp, regen, stunde, tag, wochentag, feiertag) |>
  ggpairs( aes(color = wochentag),
           lower = list(continuous = "autopoint"),
           upper = list(continuous = "points")#,
#           diag = list(continuous = "barDiag")
  )
```

Es werden im folgenden einzelne Variablen und deren Zusammenhänge individuell betrachtet.

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  dplyr::select(user, temp) |> 
  ggplot(aes(x = user)) +
  geom_histogram(fill = "lightblue", color = "black", binwidth = 1) +
  labs(title = "Verteilung der Nutzerzahlen",
       x = "Nutzer",
       y = "Häufigkeit")+
  theme_minimal()
```

Die Verteilung der Nutzerzahlen ist deutlich rechtsschief. Der Erwarungswert $\lambda$ beträgt rund `r round(mean(sharing$user, na.rm = TRUE),0)` und die Varianz beträgt rund `r format(var(sharing$user, na.rm = TRUE), big.mark = "'", scientific = FALSE, digits = 1)`. Zusammen mit der Rechtsschiefe und der Überdispersion ist es sinnvoll Poisson- und Negativ-Binomial-Modelle miteinander zu vergleichen.

### Nutzerzahlen nach Wochentag, Feiertag und Tageszeit

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  group_by(wochentag) |>
  na.omit() |>
  ggplot(aes(x = wochentag)) +
  geom_boxplot(aes(y = user, colour = feiertag)) +
  labs(title = "Nutzerzahlen nach Wochentag",
       x = "Wochentag",
       y = "Nutzer")+
  theme_minimal()

```

Die Nutzerzahlen an Feiertagen unterscheiden sich zum Teil von den Nutzerzahlen an Werktagen. Beide Prädiktoren sollten also bei den Modellen berücksichtigt werden.

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  mutate(stunde = as.factor(stunde)) |>
  group_by(wochentag) |>
  na.omit() |>
  ggplot(aes(x = wochentag)) +
  geom_boxplot(aes(y = user, colour = stunde)) +
  labs(title = "Nutzerzahlen nach Wochentag",
       x = " ",
       y = "Nutzer")+
  theme_minimal()

```

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  mutate(stunde = as.factor(stunde)) |>
  group_by(stunde) |>
  na.omit() |>
  ggplot(aes(x = stunde)) +
  geom_boxplot(aes(y = user, colour = wochentag)) +
  labs(title = "Nutzerzahlen nach Tageszeit",
       x = "Uhrzeit",
       y = "Nutzer")+
  theme_minimal()

```

Wie zu erwarten variieren die Nutzerzahlen in Abhängigkeit von der Tageszeit, als auch in Abhängigkeit vom Wochentag. Beide Prädiktoren sollten also bei den Modellen als Interaktion berücksichtigt werden. Beide Prädiktoren scheinen eine nicht-lineare Beziehung zu den Nutzerzahlen zu haben. Die Schwingung bestätigt sich auch, wenn die Nutzerzahlen über die Zeit aufgetragen werden.

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  mutate(ID = row_number()) |>
  ggplot(aes(x = ID, y = user)) +
  #geom_point() +
  geom_line() +
  #geom_line(aes(y = predicted_user), color = "blue") +
  labs(title = "Nutzerzahlen über die Zeit",
       x = "Zeit [h]",
       y = "Anzahl Nutzer")+
  theme_minimal()
```

```{r echo=FALSE, message=FALSE, warning=FALSE} 
ts <- ts(sharing.t$user, frequency = 24)
stl_user <- stl(ts, s.window = "periodic")
plot(stl_user)
decomp <- decompose(ts)
u.trend <- decomp$trend
u.sais <- decomp$seasonal
```

### Zusammenhang zwischen Nutzerzahlen, Temperatur und Regen

```{r echo=FALSE, message=FALSE, warning=FALSE}
# ggplot user over temp coloured by wochentag
sharing |> 
  ggplot(aes(x = temp, y = user)) +
  geom_point() +
  geom_smooth(method = "gam") +
  labs(title = "Nutzerzahlen über Temperatur",
       x = "Temperatur [°C]",
       y = "Anzahl Nutzer")+
  theme_minimal()


```

Es zeigt sich ein gewisser Trend, dass die Nutzerzahlen mit steigender Temperatur zunehmen.

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  mutate(ID = row_number()) |>
  ggplot(aes(x = ID, y = temp)) +
  geom_line() +
  labs(title = "Temperatur über die Zeit",
       x = "Zeit [h]",
       y = "Temperatur [°C]")+
  theme_minimal()
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  mutate(ID = row_number()) |>
  ggplot(aes(x = stunde, y = temp)) +
  geom_point() +
  labs(title = "Temperatur über die Tageszeit",
       x = "Tageszeit [h]",
       y = "Temperatur [°C]")+
  theme_minimal()
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
temp.ts <- ts(sharing.t$temp, frequency = 24)
# acf(temp.ts, lag.max = 24*7, main = "Autokorrelation der Temperatur")
stl_temp <- stl(temp.ts, s.window = "periodic")
plot(stl_temp)
#decomp <- decompose(temp.ts)
#plot(decomp)
#t.trend <- decomp$trend
```

Die Temperatur ist wie zu erwarten deutlich abhängig von der Tageszeit (saisonaler Anteil). Die Temperatur zeigt zusätzlich einen Trend-Anteil = Wetter.

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing |> 
  mutate(ID = row_number()) |>
  ggplot(aes(x = ID, y = regen)) +
  geom_line() +
  geom_point()+
  labs(title = "Regenmenge über die Zeit",
       x = "Zeit [h]",
       y = "Regen [mm]")+
  theme_minimal()


```

Bei der Mehrheit der Zeitpunkte, `r sum(sharing$regen == 0)` wird kein Niederschlag nachgewiessen. An `r sum(sharing$regen > 0 & sharing$regen < 5, na.rm = TRUE)` Zeitpunkten ist die Regenmenge kleiner als 5mm/h und an `r sum(sharing$regen > 5, na.rm = TRUE)` Zeitpunkten ist die Regenmenge grösser als 5mm/h. 

Es ist fraglich ob die Regenmenge als kontinuierliche Variable oder besser als kategorische Variable modelliert werden soll. Eine Möglichkeit wäre die Regenmenge in 2 Kategorien zu unterteilen:\
kein Regen = 0 und Regen = 1.

```{r echo=FALSE, message=FALSE, warning=FALSE}
# ggplot user over regen coloured by wochentag
sharing |> 
  ggplot(aes(x = regen, y = user)) +
  geom_point() +
  labs(title = "Nutzerzahlen über Regen",
       x = "Regen [mm/h]",
       y = "Nutzer")+
  theme_minimal()



```


### Zusammenfassung der deskriptiven Datenanalyse

-   Zielgrösse `user` in Poisson- oder Negativ-Binomial-Verteilung
-   Prädiktoren: `temp`, `regen`, `feiertag`, `wochentag`, `stunde`, `tag`
-   Interaktionen: `temp:stunde`, `temp:tag`, `feiertag:stunde`, `wochentag:stunde`
-   Nicht-lineare Beziehungen: `stunde`, `tag` als Sinus- und Cosinusfunktion modellieren
-   Prädiktor `regen` als kategorische Variable modellieren



# Modellierung {.justify}

### Einfaches Poisson-Modell ohne Interaktionen & Schwingungen

```{r, echo=F, message=F, warning=F}
sharing.t <-sharing.t |> 
  mutate(regen.bin = as.factor(ifelse(regen == 0, 0, 1)))
fit <- glm(user ~ temp + regen + feiertag + wochentag + stunde + tag, data = sharing.t, family = poisson)
fit.rb <- glm(user ~ temp + regen.bin + feiertag + wochentag + stunde + tag, data = sharing.t, family = poisson)
```

```{r, echo=F, message=F, warning=F}
summary(fit)
```

```{r, echo=F, message=F, warning=F}
drop1(fit, test = "F")
```

```{r, echo=F, message=F, warning=F}
par(mfrow=c(2,2))
plot(fit)

```

### Model mit Regen als kategorische Variable

```{r, echo=F, message=F, warning=F}
summary(fit.rb)
```

```{r, echo=F, message=F, warning=F}
drop1(fit.rb, test = "F")
```

```{r, echo=F, message=F, warning=F}
par(mfrow=c(2,2))
plot(fit.rb)

```

Durch die Modellierung von `regen` als binäre kategorische Variable konnte die Devianz etwas reduziert werden. Vor allem ist die Verbesserung im Leverage Plot sichtbar. Der Hebel des Datenpunkts #1512 (mit fast 25mm/h) wurde durch die Modellierung von `regen` als binäre Variable reduziert.

### Modell mit Interaktionen und Schwingungen

```{r, echo=F, message=F, warning=F}


fit.pois <- glm(user ~ temp * (sin(2 * pi * stunde / 24) + cos(2 * pi * stunde / 24)) + 
               feiertag * cos(2 * pi * stunde / 24) + 
               wochentag * cos(2 * pi * stunde / 24) + 
               regen.bin + 
               tag*cos(2*pi*tag/3912),
               data = sharing.t, 
             family = poisson)


s1 <- summary(fit.pois)
#fit.1$formula
s1

```
                   *   *   *   *   *   *   *
```{r, echo=F, message=F, warning=F}
drop1(fit.pois, test = "Chisq")
```

```{r, echo=F, message=F, warning=F}
par(mfrow=c(2,2))
plot(fit.pois)


```

Das Model `fit.1` erklärt `r round(1-s1$deviance/s1$null.deviance, 2)*100`% der Varianz der Nutzerzahlen. Die Devianz konnte im Vergleich zum einfachen Modell deutlich reduziert werden. Die als Schwingungen modellierten Interaktionen zwischen Temperatur und Tageszeiten, als auch zwischen Wochen- & Feiertage und Stunden haben einen signifikanten Einfluss auf die Nutzerzahlen.

```{r, echo=F, message=F, warning=F}
#negbin
library(MASS)
fit.nb <- glm.nb(user ~ temp * (sin(2 * pi * stunde / 24) + cos(2 * pi * stunde / 24)) + 
               feiertag * cos(2 * pi * stunde / 24) + 
               wochentag * cos(2 * pi * stunde / 24) + 
               regen.bin + 
               tag*cos(2*pi*tag/3912), data = sharing.t)


s.nb <- summary(fit.nb)
#s.nb
#1-s.nb$deviance/s.nb$null.deviance
s.nb
```

                   *   *   *   *   *   *   *
```{r, echo=F, message=F, warning=F}
drop1(fit.nb, test = "Chisq")
par(mfrow=c(2,2))
plot(fit.nb)



```

Das Modell `fit.nb` erklärt `r round(1-s.nb$deviance/s.nb$null.deviance,1)*100`% der Varianz der Nutzerzahlen. Die Devianz konnte im Vergleich zum Poisson Modell deutlich reduziert werden. 
Der Scale-Location-Plot und der Residuenplot zeigen beide eine Stabilisierung gegenüber dem Poisson-Modell.
Und der AIC-Vergleich zeigt:
.
```{r echo=FALSE, message=FALSE, warning=FALSE}
df <- AIC(fit, fit.rb, fit.pois, fit.nb)
df
```
## Punktvorhersagen mit 95% Prognoseintervallen
```{r echo=FALSE, message=FALSE, warning=FALSE}
# Vorhersagen berechnen


sharing.p <- sharing |> 
  mutate(regen.bin = as.factor(ifelse(regen == 0, 0, 1)))


#sharing.p$predicted_user <- predict(fit.pois, newdata = sharing.p, type = "response")

na.index <- which(is.na(sharing.p$user))
sharing.p$user.pred <- NA
sharing.p$user.pred[na.index] <- predict(fit.nb, newdata = sharing.p[na.index,], type = "response")
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# vorhersage und 95% Konfidenzintervall
sharing_na.p <- sharing_na |>
  mutate(regen.bin = as.factor(ifelse(regen == 0, 0, 1)))

sharing.p <- sharing |> 
  mutate(regen.bin = as.factor(ifelse(regen == 0, 0, 1)))

na.index <- which(is.na(sharing.p$user))
  
p <- predict(fit.nb, newdata = sharing_na.p, type = "link", se.fit = TRUE)
#mu <- exp(rnorm(n = length(p$fit), mean = p$fit, sd = p$se.fit))
#beob <- rnegbin(n = length(p$fit), mu = mu, theta = summary(fit.nb$theta))

# Anzahl der Simulationen pro Vorhersage
nsim <- 10000

# Matrix zur Speicherung der simulierten mu-Werte
mu <- matrix(nrow = length(p$fit), ncol = nsim)

# Simulation der mu-Werte
for (i in 1:length(p$fit)) {
  mu[i, ] <- exp(rnorm(n = nsim, mean = p$fit[i], sd = p$se.fit[i]))
}

# Dispersionsparameter theta aus dem Modell
theta <- fit.nb$theta

# Matrix zur Speicherung der simulierten Beobachtungen
beob <- matrix(nrow = length(p$fit), ncol = nsim)

# Simulation der Beobachtungen
for (i in 1:length(p$fit)) {
  beob[i, ] <- rnegbin(n = nsim, mu = mu[i, ], theta = theta)
}

# eintragen der Prognosen und der Prognose-Intervalle

# sharing_na.p <- sharing_na.p |> 
#   mutate(
#     user = exp(p$fit),
#     unterer_PI = apply(beob, 1, quantile, probs = 0.025, type = 1),
#     oberer_PI = apply(beob, 1, quantile, probs = 0.975, type = 1)
# )

sharing.p$unterer_PI <- NA
sharing.p$oberer_PI <- NA
sharing.p <- sharing.p |> 
  mutate(na.user = ifelse(is.na(user), "Prognose", "Beobachtung"))

sharing.p[na.index,] <- sharing.p[na.index,] |> 
  mutate(
    user = round(exp(p$fit), 0),
    unterer_PI = apply(beob, 1, quantile, probs = 0.025, type = 1),
    oberer_PI = apply(beob, 1, quantile, probs = 0.975, type = 1)
)
```

```{r echo=FALSE, message=FALSE, warning=FALSE}
sharing.p |> 
  mutate(ID = row_number()) |>
  ggplot(aes(x = ID, y = user, color = na.user, group = 1)) +
  geom_line() +
  scale_color_manual(values = c("beob" = "grey", "prog" = "navy")) +
  labs(title = "User Values with Imputed Data Highlighted",
       x = "Zeit [h]",
       y = "Nutzerzahlen",
       color = "Data Type") +
  theme_minimal()
  

sharing.p.p <- sharing.p  |> 
  mutate(
    ID = row_number(),
    unterer_PI = if_else(is.na(unterer_PI), user, unterer_PI),
    oberer_PI = if_else(is.na(oberer_PI), user, oberer_PI)
                           
    )
  


ggplot(data = sharing.p.p, aes(x = ID)) +
  # geom_ribbon(aes(ymin = unterer_PI, ymax = oberer_PI#, fill = na.user
  #                 ),  alpha = 0.5, fill = "red") +
  geom_line(aes(y = user, color = na.user, group = 1, linetype = "user")) +
  geom_line(aes(y = unterer_PI, 
                #color = na.user, group = 1, 
                linetype = "PI"), color = "#555555", alpha=0.8) +
  geom_line(aes(y = oberer_PI, 
                #color = na.user, group = 1, 
                linetype = "PI"), color = "#555555", alpha=0.8) +
  scale_color_manual(values = c("Beobachtung" = "#555555", "Prognose" = "blue")) +
  scale_linetype_manual(
    values = c("user" = "solid", "PI" = "dotted"),
    name = "Linientyp",
    labels = c("user" = "Nutzerzahlen", "PI" = "Prognoseintervall")
  ) +
  labs(title = "Nutzerzahl-Prognosen mit 95% Prognoseintervall, ",
       x = "Zeit [h]",
       y = "Nutzerzahlen",
       fill = "na.user",
       color = NULL) +
  theme_minimal()



```

```{r echo=FALSE, message=FALSE, warning=FALSE}
# sharing.p |> 
#   mutate(ID = row_number()) |>
#   pivot_longer(cols = c(user, user.pred), names_to = "Type", values_to = "Count") |> 
#   ggplot(aes(x = ID, y = Count, color = Type)) +
#   geom_line() +
#   scale_y_continuous(limits = c(0, 620)) +
#   labs(
#     title = "Nutzerzahlen über die Zeit mit negativ-binomial-Modell",
#     x = "Zeit [h]",
#     y = "Anzahl Nutzer"
#   ) +
#   scale_color_manual(
#     values = c("user" = "lightblue", "user.pred" = "navy"),
#     labels = c("Beobachtete Nutzerzahlen", "Vorhergesagte Nutzerzahlen"),
#     name = "Datenquelle"
#   ) +
#   theme_minimal()
  

```


```{r echo=FALSE, message=FALSE, warning=FALSE}
# sharing.p$predicted_user_nb <- predict(fit.nb, newdata = sharing.p, type = "response")
# sharing.p |> 
#   mutate(ID = row_number()) |>
#   ggplot(aes(x = ID, y = predicted_user_nb)) +
#   #geom_point() +
#   #geom_line() +
#   geom_line(color = "navy") +
#   #geom_line(aes(y = predicted_user), color = "orange") +
#   #geom_line(aes(y = user), color = "red") +
#   scale_y_continuous(limits = c(0, 620))+
#   labs(title = "modellierte Nutzerzahlen über die Zeit mit negativ-binomial-Modell",
#        x = "Zeit [h]",
#        y = "Anzahl Nutzer")+
#   theme_minimal()

```



```{r echo=FALSE, message=FALSE, warning=FALSE}
s <- sharing.p[,-c(8,11)] 
save(s, file = "sharing_speeroli.rda")




```

